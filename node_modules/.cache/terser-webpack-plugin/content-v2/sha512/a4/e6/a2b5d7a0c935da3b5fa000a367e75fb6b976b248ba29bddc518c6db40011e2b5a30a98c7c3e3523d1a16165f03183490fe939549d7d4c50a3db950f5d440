{"map":"{\"version\":3,\"sources\":[\"C:\\\\Users\\\\Gabriel\\\\Desktop\\\\projetos\\\\tozi_mobile(backup antes firebase)\\\\node_modules\\\\@ionic\\\\core\\\\dist\\\\esm\\\\legacy\\\\input-shims-667d45fc.js.pre-build-optimizer.js\"],\"names\":[\"__webpack_require__\",\"r\",\"__webpack_exports__\",\"d\",\"startInputShims\",\"_chunk_d102c9d1_js__WEBPACK_IMPORTED_MODULE_0__\",\"cloneMap\",\"WeakMap\",\"relocateInput\",\"componentEl\",\"inputEl\",\"shouldRelocate\",\"inputRelativeY\",\"has\",\"parentEl\",\"parentNode\",\"clonedEl\",\"cloneNode\",\"classList\",\"add\",\"tabIndex\",\"appendChild\",\"set\",\"tx\",\"ownerDocument\",\"dir\",\"style\",\"pointerEvents\",\"transform\",\"addClone\",\"clone\",\"get\",\"delete\",\"remove\",\"removeClone\",\"isFocused\",\"input\",\"getRootNode\",\"activeElement\",\"SKIP_SELECTOR\",\"SCROLL_ASSIST_SPEED\",\"PADDING_TIMER_KEY\",\"setScrollPadding\",\"keyboardHeight\",\"tagName\",\"parentElement\",\"el\",\"closest\",\"timer\",\"clearTimeout\",\"setProperty\",\"setTimeout\",\"INPUT_BLURRING\",\"SCROLL_PADDING\",\"config\",\"doc\",\"document\",\"getNumber\",\"scrollAssist\",\"getBoolean\",\"hideCaret\",\"inputBlurring\",\"scrollPadding\",\"hideCaretMap\",\"scrollAssistMap\",\"registerInput\",\"shadowRoot\",\"querySelector\",\"scrollEl\",\"rmFn\",\"scrollHideCaret\",\"shouldHideCaret\",\"onBlur\",\"showCaret\",\"addEventListener\",\"removeEventListener\",\"enableHideCaretOnScroll\",\"contentEl\",\"coord\",\"touchStart\",\"ev\",\"Object\",\"touchEnd\",\"threshold\",\"startCoord\",\"endCoord\",\"deltaX\",\"x\",\"deltaY\",\"y\",\"hasPointerMoved\",\"preventDefault\",\"stopPropagation\",\"scrollData\",\"inputRect\",\"contentRect\",\"platformHeight\",\"inputTop\",\"top\",\"inputBottom\",\"bottom\",\"visibleAreaTop\",\"safeAreaTop\",\"distanceToBottom\",\"Math\",\"min\",\"defaultView\",\"innerHeight\",\"distanceToTop\",\"desiredScrollAmount\",\"round\",\"scrollAmount\",\"distance\",\"abs\",\"scrollDuration\",\"max\",\"inputSafeY\",\"calcScrollData\",\"getBoundingClientRect\",\"getScrollData\",\"focus\",\"scrollByPoint\",\"then\",\"jsSetFocus\",\"enableScrollAssist\",\"focused\",\"didScroll\",\"active\",\"matches\",\"tapped\",\"target\",\"blur\",\"enableInputBlurring\",\"enableScrollPadding\",\"_i\",\"inputs_1\",\"Array\",\"from\",\"querySelectorAll\",\"length\",\"body\",\"event\",\"fn\"],\"mappings\":\"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\",\"sourcesContent\":[\"import { p as pointerCoord } from './chunk-d102c9d1.js';\\nvar cloneMap = new WeakMap();\\nfunction relocateInput(componentEl, inputEl, shouldRelocate, inputRelativeY) {\\n    if (inputRelativeY === void 0) { inputRelativeY = 0; }\\n    if (cloneMap.has(componentEl) === shouldRelocate) {\\n        return;\\n    }\\n    if (shouldRelocate) {\\n        addClone(componentEl, inputEl, inputRelativeY);\\n    }\\n    else {\\n        removeClone(componentEl, inputEl);\\n    }\\n}\\nfunction isFocused(input) {\\n    return input === input.getRootNode().activeElement;\\n}\\nfunction addClone(componentEl, inputEl, inputRelativeY) {\\n    // this allows for the actual input to receive the focus from\\n    // the user's touch event, but before it receives focus, it\\n    // moves the actual input to a location that will not screw\\n    // up the app's layout, and does not allow the native browser\\n    // to attempt to scroll the input into place (messing up headers/footers)\\n    // the cloned input fills the area of where native input should be\\n    // while the native input fakes out the browser by relocating itself\\n    // before it receives the actual focus event\\n    // We hide the focused input (with the visible caret) invisible by making it scale(0),\\n    var parentEl = inputEl.parentNode;\\n    // DOM WRITES\\n    var clonedEl = inputEl.cloneNode(false);\\n    clonedEl.classList.add('cloned-input');\\n    clonedEl.tabIndex = -1;\\n    parentEl.appendChild(clonedEl);\\n    cloneMap.set(componentEl, clonedEl);\\n    var doc = componentEl.ownerDocument;\\n    var tx = doc.dir === 'rtl' ? 9999 : -9999;\\n    componentEl.style.pointerEvents = 'none';\\n    inputEl.style.transform = \\\"translate3d(\\\" + tx + \\\"px,\\\" + inputRelativeY + \\\"px,0) scale(0)\\\";\\n}\\nfunction removeClone(componentEl, inputEl) {\\n    var clone = cloneMap.get(componentEl);\\n    if (clone) {\\n        cloneMap.delete(componentEl);\\n        clone.remove();\\n    }\\n    componentEl.style.pointerEvents = '';\\n    inputEl.style.transform = '';\\n}\\nfunction enableHideCaretOnScroll(componentEl, inputEl, scrollEl) {\\n    if (!scrollEl || !inputEl) {\\n        return function () { return; };\\n    }\\n    var scrollHideCaret = function (shouldHideCaret) {\\n        if (isFocused(inputEl)) {\\n            relocateInput(componentEl, inputEl, shouldHideCaret);\\n        }\\n    };\\n    var onBlur = function () { return relocateInput(componentEl, inputEl, false); };\\n    var hideCaret = function () { return scrollHideCaret(true); };\\n    var showCaret = function () { return scrollHideCaret(false); };\\n    scrollEl.addEventListener('ionScrollStart', hideCaret);\\n    scrollEl.addEventListener('ionScrollEnd', showCaret);\\n    inputEl.addEventListener('blur', onBlur);\\n    return function () {\\n        scrollEl.removeEventListener('ionScrollStart', hideCaret);\\n        scrollEl.removeEventListener('ionScrollEnd', showCaret);\\n        inputEl.addEventListener('ionBlur', onBlur);\\n    };\\n}\\nvar SKIP_SELECTOR = 'input, textarea, [no-blur]';\\nfunction enableInputBlurring() {\\n    var doc = document;\\n    var focused = true;\\n    var didScroll = false;\\n    function onScroll() {\\n        didScroll = true;\\n    }\\n    function onFocusin() {\\n        focused = true;\\n    }\\n    function onTouchend(ev) {\\n        // if app did scroll return early\\n        if (didScroll) {\\n            didScroll = false;\\n            return;\\n        }\\n        var active = doc.activeElement;\\n        if (!active) {\\n            return;\\n        }\\n        // only blur if the active element is a text-input or a textarea\\n        if (active.matches(SKIP_SELECTOR)) {\\n            return;\\n        }\\n        // if the selected target is the active element, do not blur\\n        var tapped = ev.target;\\n        if (tapped === active) {\\n            return;\\n        }\\n        if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {\\n            return;\\n        }\\n        focused = false;\\n        // TODO: find a better way, why 50ms?\\n        setTimeout(function () {\\n            if (!focused) {\\n                active.blur();\\n            }\\n        }, 50);\\n    }\\n    doc.addEventListener('ionScrollStart', onScroll);\\n    doc.addEventListener('focusin', onFocusin, true);\\n    doc.addEventListener('touchend', onTouchend, false);\\n    return function () {\\n        doc.removeEventListener('ionScrollStart', onScroll, true);\\n        doc.removeEventListener('focusin', onFocusin, true);\\n        doc.removeEventListener('touchend', onTouchend, false);\\n    };\\n}\\nvar SCROLL_ASSIST_SPEED = 0.3;\\nfunction getScrollData(componentEl, contentEl, keyboardHeight) {\\n    var itemEl = componentEl.closest('ion-item,[ion-item]') || componentEl;\\n    return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, componentEl.ownerDocument.defaultView.innerHeight);\\n}\\nfunction calcScrollData(inputRect, contentRect, keyboardHeight, platformHeight) {\\n    // compute input's Y values relative to the body\\n    var inputTop = inputRect.top;\\n    var inputBottom = inputRect.bottom;\\n    // compute visible area\\n    var visibleAreaTop = contentRect.top;\\n    var visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight);\\n    // compute safe area\\n    var safeAreaTop = visibleAreaTop + 15;\\n    var safeAreaBottom = visibleAreaBottom * 0.5;\\n    // figure out if each edge of the input is within the safe area\\n    var distanceToBottom = safeAreaBottom - inputBottom;\\n    var distanceToTop = safeAreaTop - inputTop;\\n    // desiredScrollAmount is the negated distance to the safe area according to our calculations.\\n    var desiredScrollAmount = Math.round((distanceToBottom < 0)\\n        ? -distanceToBottom\\n        : (distanceToTop > 0)\\n            ? -distanceToTop\\n            : 0);\\n    // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input\\n    // gets focus, so make sure we don't scroll the input above the visible area\\n    var scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);\\n    var distance = Math.abs(scrollAmount);\\n    var duration = distance / SCROLL_ASSIST_SPEED;\\n    var scrollDuration = Math.min(400, Math.max(150, duration));\\n    return {\\n        scrollAmount: scrollAmount,\\n        scrollDuration: scrollDuration,\\n        scrollPadding: keyboardHeight,\\n        inputSafeY: -(inputTop - safeAreaTop) + 4\\n    };\\n}\\nfunction enableScrollAssist(componentEl, inputEl, contentEl, keyboardHeight) {\\n    var coord;\\n    var touchStart = function (ev) {\\n        coord = pointerCoord(ev);\\n    };\\n    var touchEnd = function (ev) {\\n        // input cover touchend/mouseup\\n        if (!coord) {\\n            return;\\n        }\\n        // get where the touchend/mouseup ended\\n        var endCoord = pointerCoord(ev);\\n        // focus this input if the pointer hasn't moved XX pixels\\n        // and the input doesn't already have focus\\n        if (!hasPointerMoved(6, coord, endCoord) && !isFocused(inputEl)) {\\n            ev.preventDefault();\\n            ev.stopPropagation();\\n            // begin the input focus process\\n            jsSetFocus(componentEl, inputEl, contentEl, keyboardHeight);\\n        }\\n    };\\n    componentEl.addEventListener('touchstart', touchStart, true);\\n    componentEl.addEventListener('touchend', touchEnd, true);\\n    return function () {\\n        componentEl.removeEventListener('touchstart', touchStart, true);\\n        componentEl.removeEventListener('touchend', touchEnd, true);\\n    };\\n}\\nfunction jsSetFocus(componentEl, inputEl, contentEl, keyboardHeight) {\\n    var scrollData = getScrollData(componentEl, contentEl, keyboardHeight);\\n    if (Math.abs(scrollData.scrollAmount) < 4) {\\n        // the text input is in a safe position that doesn't\\n        // require it to be scrolled into view, just set focus now\\n        inputEl.focus();\\n        return;\\n    }\\n    // temporarily move the focus to the focus holder so the browser\\n    // doesn't freak out while it's trying to get the input in place\\n    // at this point the native text input still does not have focus\\n    relocateInput(componentEl, inputEl, true, scrollData.inputSafeY);\\n    inputEl.focus();\\n    // scroll the input into place\\n    contentEl.scrollByPoint(0, scrollData.scrollAmount, scrollData.scrollDuration).then(function () {\\n        // the scroll view is in the correct position now\\n        // give the native text input focus\\n        relocateInput(componentEl, inputEl, false, scrollData.inputSafeY);\\n        // ensure this is the focused input\\n        inputEl.focus();\\n    });\\n}\\nfunction hasPointerMoved(threshold, startCoord, endCoord) {\\n    if (startCoord && endCoord) {\\n        var deltaX = (startCoord.x - endCoord.x);\\n        var deltaY = (startCoord.y - endCoord.y);\\n        var distance = deltaX * deltaX + deltaY * deltaY;\\n        return distance > (threshold * threshold);\\n    }\\n    return false;\\n}\\nvar PADDING_TIMER_KEY = '$ionPaddingTimer';\\nfunction enableScrollPadding(keyboardHeight) {\\n    var doc = document;\\n    function onFocusin(ev) {\\n        setScrollPadding(ev.target, keyboardHeight);\\n    }\\n    function onFocusout(ev) {\\n        setScrollPadding(ev.target, 0);\\n    }\\n    doc.addEventListener('focusin', onFocusin);\\n    doc.addEventListener('focusout', onFocusout);\\n    return function () {\\n        doc.removeEventListener('focusin', onFocusin);\\n        doc.removeEventListener('focusout', onFocusout);\\n    };\\n}\\nfunction setScrollPadding(input, keyboardHeight) {\\n    if (input.tagName !== 'INPUT') {\\n        return;\\n    }\\n    if (input.parentElement && input.parentElement.tagName === 'ION-INPUT') {\\n        return;\\n    }\\n    if (input.parentElement &&\\n        input.parentElement.parentElement &&\\n        input.parentElement.parentElement.tagName === 'ION-SEARCHBAR') {\\n        return;\\n    }\\n    var el = input.closest('ion-content');\\n    if (el === null) {\\n        return;\\n    }\\n    var timer = el[PADDING_TIMER_KEY];\\n    if (timer) {\\n        clearTimeout(timer);\\n    }\\n    if (keyboardHeight > 0) {\\n        el.style.setProperty('--keyboard-offset', keyboardHeight + \\\"px\\\");\\n    }\\n    else {\\n        el[PADDING_TIMER_KEY] = setTimeout(function () {\\n            el.style.setProperty('--keyboard-offset', '0px');\\n        }, 120);\\n    }\\n}\\nvar INPUT_BLURRING = true;\\nvar SCROLL_PADDING = true;\\nfunction startInputShims(config) {\\n    var doc = document;\\n    var keyboardHeight = config.getNumber('keyboardHeight', 290);\\n    var scrollAssist = config.getBoolean('scrollAssist', true);\\n    var hideCaret = config.getBoolean('hideCaretOnScroll', true);\\n    var inputBlurring = config.getBoolean('inputBlurring', true);\\n    var scrollPadding = config.getBoolean('scrollPadding', true);\\n    var hideCaretMap = new WeakMap();\\n    var scrollAssistMap = new WeakMap();\\n    function registerInput(componentEl) {\\n        var inputEl = (componentEl.shadowRoot || componentEl).querySelector('input') || (componentEl.shadowRoot || componentEl).querySelector('textarea');\\n        var scrollEl = componentEl.closest('ion-content');\\n        if (!inputEl) {\\n            return;\\n        }\\n        if (!!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {\\n            var rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);\\n            hideCaretMap.set(componentEl, rmFn);\\n        }\\n        if (!!scrollEl && scrollAssist && !scrollAssistMap.has(componentEl)) {\\n            var rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, keyboardHeight);\\n            scrollAssistMap.set(componentEl, rmFn);\\n        }\\n    }\\n    function unregisterInput(componentEl) {\\n        if (hideCaret) {\\n            var fn = hideCaretMap.get(componentEl);\\n            if (fn) {\\n                fn();\\n            }\\n            hideCaretMap.delete(componentEl);\\n        }\\n        if (scrollAssist) {\\n            var fn = scrollAssistMap.get(componentEl);\\n            if (fn) {\\n                fn();\\n            }\\n            scrollAssistMap.delete(componentEl);\\n        }\\n    }\\n    if (inputBlurring && INPUT_BLURRING) {\\n        enableInputBlurring();\\n    }\\n    if (scrollPadding && SCROLL_PADDING) {\\n        enableScrollPadding(keyboardHeight);\\n    }\\n    // Input might be already loaded in the DOM before ion-device-hacks did.\\n    // At this point we need to look for all of the inputs not registered yet\\n    // and register them.\\n    var inputs = Array.from(doc.querySelectorAll('ion-input, ion-textarea'));\\n    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\\n        var input = inputs_1[_i];\\n        registerInput(input);\\n    }\\n    doc.body.addEventListener('ionInputDidLoad', function (event) {\\n        registerInput(event.target);\\n    });\\n    doc.body.addEventListener('ionInputDidUnload', function (event) {\\n        unregisterInput(event.target);\\n    });\\n}\\nexport { startInputShims };\\n\"]}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{AbJG:function(t,e,n){\"use strict\";n.r(e),n.d(e,\"startInputShims\",function(){return v});var o=n(\"7gGu\"),r=new WeakMap;function a(t,e,n,o){void 0===o&&(o=0),r.has(t)!==n&&(n?function(t,e,n){var o=e.parentNode,a=e.cloneNode(!1);a.classList.add(\"cloned-input\"),a.tabIndex=-1,o.appendChild(a),r.set(t,a);var i=\"rtl\"===t.ownerDocument.dir?9999:-9999;t.style.pointerEvents=\"none\",e.style.transform=\"translate3d(\"+i+\"px,\"+n+\"px,0) scale(0)\"}(t,e,o):function(t,e){var n=r.get(t);n&&(r.delete(t),n.remove()),t.style.pointerEvents=\"\",e.style.transform=\"\"}(t,e))}function i(t){return t===t.getRootNode().activeElement}var u=\"input, textarea, [no-blur]\",c=.3;var s=\"$ionPaddingTimer\";function l(t,e){if(\"INPUT\"===t.tagName&&!(t.parentElement&&\"ION-INPUT\"===t.parentElement.tagName||t.parentElement&&t.parentElement.parentElement&&\"ION-SEARCHBAR\"===t.parentElement.parentElement.tagName)){var n=t.closest(\"ion-content\");if(null!==n){var o=n[s];o&&clearTimeout(o),e>0?n.style.setProperty(\"--keyboard-offset\",e+\"px\"):n[s]=setTimeout(function(){n.style.setProperty(\"--keyboard-offset\",\"0px\")},120)}}}var d=!0,f=!0;function v(t){var e=document,n=t.getNumber(\"keyboardHeight\",290),r=t.getBoolean(\"scrollAssist\",!0),s=t.getBoolean(\"hideCaretOnScroll\",!0),v=t.getBoolean(\"inputBlurring\",!0),m=t.getBoolean(\"scrollPadding\",!0),p=new WeakMap,E=new WeakMap;function g(t){var e=(t.shadowRoot||t).querySelector(\"input\")||(t.shadowRoot||t).querySelector(\"textarea\"),u=t.closest(\"ion-content\");if(e){if(u&&s&&!p.has(t)){var l=function(t,e,n){if(!n||!e)return function(){};var o=function(n){i(e)&&a(t,e,n)},r=function(){return a(t,e,!1)},u=function(){return o(!0)},c=function(){return o(!1)};return n.addEventListener(\"ionScrollStart\",u),n.addEventListener(\"ionScrollEnd\",c),e.addEventListener(\"blur\",r),function(){n.removeEventListener(\"ionScrollStart\",u),n.removeEventListener(\"ionScrollEnd\",c),e.addEventListener(\"ionBlur\",r)}}(t,e,u);p.set(t,l)}u&&r&&!E.has(t)&&(l=function(t,e,n,r){var u,s=function(t){u=Object(o.j)(t)},l=function(s){u&&(function(t,e,n){if(u&&n){var o=u.x-n.x,r=u.y-n.y;return o*o+r*r>36}return!1}(0,0,Object(o.j)(s))||i(e)||(s.preventDefault(),s.stopPropagation(),function(t,e,n,o){var r=function(t,e,n){return function(e,n,o,r){var a=e.top,i=e.bottom,u=n.top,s=u+15,l=.5*Math.min(n.bottom,t.ownerDocument.defaultView.innerHeight-o)-i,d=s-a,f=Math.round(l<0?-l:d>0?-d:0),v=Math.min(f,a-u),m=Math.abs(v);return{scrollAmount:v,scrollDuration:Math.min(400,Math.max(150,m/c)),scrollPadding:o,inputSafeY:4-(a-s)}}((t.closest(\"ion-item,[ion-item]\")||t).getBoundingClientRect(),e.getBoundingClientRect(),n)}(t,n,o);Math.abs(r.scrollAmount)<4?e.focus():(a(t,e,!0,r.inputSafeY),e.focus(),n.scrollByPoint(0,r.scrollAmount,r.scrollDuration).then(function(){a(t,e,!1,r.inputSafeY),e.focus()}))}(t,e,n,r)))};return t.addEventListener(\"touchstart\",s,!0),t.addEventListener(\"touchend\",l,!0),function(){t.removeEventListener(\"touchstart\",s,!0),t.removeEventListener(\"touchend\",l,!0)}}(t,e,u,n),E.set(t,l))}}v&&d&&function(){var t=document,e=!0,n=!1;t.addEventListener(\"ionScrollStart\",function(){n=!0}),t.addEventListener(\"focusin\",function(){e=!0},!0),t.addEventListener(\"touchend\",function(o){if(n)n=!1;else{var r=t.activeElement;if(r&&!r.matches(u)){var a=o.target;a!==r&&(a.matches(u)||a.closest(u)||(e=!1,setTimeout(function(){e||r.blur()},50)))}}},!1)}(),m&&f&&function(t){var e=document;e.addEventListener(\"focusin\",function(e){l(e.target,t)}),e.addEventListener(\"focusout\",function(t){l(t.target,0)})}(n);for(var h=0,y=Array.from(e.querySelectorAll(\"ion-input, ion-textarea\"));h<y.length;h++)g(y[h]);e.body.addEventListener(\"ionInputDidLoad\",function(t){g(t.target)}),e.body.addEventListener(\"ionInputDidUnload\",function(t){var e,n;e=t.target,s&&((n=p.get(e))&&n(),p.delete(e)),r&&((n=E.get(e))&&n(),E.delete(e))})}}}]);","extractedComments":[]}